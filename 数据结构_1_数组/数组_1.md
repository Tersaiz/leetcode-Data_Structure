# 1.寻找数组的中心索引

>题目描述：给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。

![示例](images\数组_2.jpg)

## 解题思路

+ 1.因为数组中的值的的范围时[0，100]，所以我们先定义一个长度为101的数组a[101]，数组下标代表的是题目所给数组的值，数组的内容代表的是原数组某个取值所在的位置。  例如：原数组为[1,2,3],则新数组a[0]不赋值，a[1] = 0,a[2] = 1,a[3] = 2,其余不赋值。其中，a[1] = 0 中的1代表原数组中的1，0代表1在原数组中位于第0位
+ 2.将原数组从大至小进行排序
+ 3.排序完成后，第一个元素值最大，第二个元素次之，只需要判断第二个元素的2倍，是否小于第一个元素。
+ 4.若3成立，则在a中返回原数组中最大数据的下标
+ 5.若3不成立，返回-1

## 代码（c语言版本）

```c
int dominantIndex(int* nums, int numsSize){
    int a[101];
    int i,j;
    int t;

    if (numsSize == 1)
        return 0;
    //保存原数组的不同元素的位置信息
    for (i = 0;i<numsSize;++i)
    {
        a[nums[i]] = i;
    }
    //从大到小进行排序
    for (i=0;i<2;++i)
    {
        for (j=i+1;j<numsSize;++j)
        {
            if (nums[i]<nums[j])
            {
                t = nums[i];
                nums[i] = nums[j];
                nums[j] = t;
            }
        }
    }
    //判断并且返回
    if(nums[0] >= nums[1]*2)
        return a[nums[0]];
    else
        return -1;

}
```
